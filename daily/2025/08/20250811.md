# 20250811

`kotlin` `spring`

[code](/spring/jpa/JpaManualConfig.kt)

# JPA 반수동 세팅

보통 프로젝트를 세팅할때 `application.yml` 에 설정만 잘 해둔다면 **Spring Starter** 가 자동으로 JPA 세팅을 해준다.

만약 스타터가 해주지 않는다면(못한다면) 직접 세팅을 해야하는데 이때 세팅하는 방법에 대해 설명한다.

JPA 를 사용하기 위해선 크게

1. DataSource
2. EntityManagerFactory
3. TransactionManager

가 필요하다.

## DataSource

데이터 소스는 자바에서 DB 연결을 효율적으로 관리하기 위해 추상화시킨 개념이다.
Jpa Starter 를 사용하면 자동으로 HikariCP를 사용해 데이터소스가 생성되지만, 이 글에서는 직접 생성하는 방법에 대해 설명한다.

```kotlin
@Bean
@ConfigurationProperties(prefix = "spring.datasource.business")
fun businessDataSource(): DataSource {
  return DataSourceBuilder.create().build()
}
```

위 방법도 완전 수동으로 설정하는것이 아닌, 스프링부트의 도움을 받아 설정하는 방법이다.

위와같이 설정해두면 `application.yml` 의 `spring.datasource.business` 에 정의된 설정값에 따라 데이터 소스 (SpringBoot의 기본 데이터소스인 HikariCP로) 생성된다.

```yaml
spring:
  datasource:
    business:
      jdbc-url: jdbc:mysql://localhost:3306/mydb
      username: root
      password: 1234
      driver-class-name: com.mysql.cj.jdbc.Driver
```

여기서 주의할 점은 DataSource를 직접 설정할때는 `jdbc-url` 이라는 정보가 필요하다는 것이다.

## EntityManagerFactory

데이터 소스가 있다면 JPA 에서 가장 중요한 엔티티매니저를 관리할 팩토리를 생성해야 한다.

아래 소스코드는 데이터 소스를 기반으로 엔티티 매니저 팩토리를 생성하는 예제다.

```kotlin
@Bean
fun dataEntityManagerFactory(): LocalContainerEntityManagerFactoryBean {
  val em = LocalContainerEntityManagerFactoryBean()

  em.dataSource = businessDataSource()
  em.setPackagesToScan("batch.adapter.out.persistence", "core.entity")
  em.jpaVendorAdapter = HibernateJpaVendorAdapter()

  val properties = HashMap<String, Any>()
  properties["hibernate.hbm2ddl.auto"] = "update"

  em.setJpaPropertyMap(properties)

  return em
}
```

위 예제에서는 데이터소스를 위에서 정의한 데이터소스빈을 사용하고, JPA 구현체를 하이버네이트로 설정하는 방법이다.

또한 `application.yml` 에 선언한 값으로 `emf` 가 생성되는것이 아니기 때문에 직접 설정값 (`ddl-auto`) 을 채워주고 있다.

## TransactionManager

일반적으로 엔티티 매니저의 영속성 컨텍스트 라이프사이클은 트랜잭션 범위 내에서 동작한다.

스프링은 이러한 트랜잭션을 관리하기 위해 `PlatformTransactionManager` 라는 인터페이스를 제공한다.

이는 데이터베이스의 특정 벤더, 데이터소스(JDBC, JPA, 등...)와 관련해 트랜잭션을 제어할 수 있는 구현체들을 제공한다.

이 글에서는 JPA의 범위 내에서 트랜잭션을 제어할 것이기 때문에 `JpaTransactionManager` 구현체를 사용해 트랜잭션 매니저를 정의한다.

```kotlin
@Bean
fun dataTransactionManager(): PlatformTransactionManager {
  val transactionManger = JpaTransactionManager()
  transactionManger.entityManagerFactory = dataEntityManagerFactory().getObject()
  return transactionManger
}
```

`JpaTransactionManager` 구현체를 사용하고, 엔티티 매니저로 위에서 정의한 `emf` 를 주입해준다.

# 그래서 이걸 어디다써?

사실 데이터소스가 하나라면 이런 작업을 굳이 할필요 없다. 하지만 데이터 소스가 여러개 사용해야 하는 상황이라면 일반적인 Starter 의 세팅으로는 불가능 하다.

이럴때 스프링 부트의 도움을 받아 JPA를 반수동으로 설정해 트랜잭션과 `emf` 를 제어할 수 있는 것이다.

나의 경우 보안 정책과, 요구사항을 만족하려다 보니 데이터 소스가 여러개가 되었다.

# 추가 JPA 수동 설정 관련 팁

Spring Data JPA 에서 `emf` 는 기본적으로 `@EnableJpaRepositories` 나 `@SpringBootApplication` 의 하위 패키지를 스캔한다.

하지만 만약 엔티티가 밖에 빠져있는 상황이라면 (ex 멀티모듈) 패키지를 수동으로 설정해줘야 한다.

이때 `Spring Boot Starter` 를 사용한다면 편하게 `@EntityScan` 을 사용해 스캔 범위를 지정할 수 있다.

아니면 위처럼 `emf` 를 수동으로 정의하는 상황이라면 `em.setPackagesToScan("batch.adapter.out.persistence", "core.entity")` 이렇게 직접 엔티티 스캔 범위를 지정해줄 수 있다.

# 배운점

지금까지 JPA를 쓰면서 `application.yml` 에 `datasource` 에다 설정만 하면 크게 문제가 생기지 않아서 이런 내부 과정을 잘 알지 못했다.

직접 완전 수동으로는 아니지만 JPA를 세팅해보면서 어떤 것들이 필요하고, 스프링 부트가 어떻게 프로젝트를 세팅하는데 도움을 주는지 확실히 배우게 되었다.
